version: 2 # use CircleCI 2.0 instead of CircleCI Classic
jobs: # basic units of work in a run
  build: # runs not using Workflows must have a `build` job as entry point
    parallelism: 1 # run only one instance of this job in parallel
    docker: # run the steps with Docker
      - image: cimg/elixir:1.16.0-erlang-26.2.1
        environment: # environment variables for primary container
          MIX_ENV: test
      - image: cimg/postgres:15.5-postgis # database image

    working_directory: ~/app # directory where steps will run

    steps: # commands that comprise the `build` job
      - checkout # check out source code to working directory

      - run: mix local.hex --force # install Hex locally (without prompt)
      - run: mix local.rebar --force # fetch a copy of rebar (without prompt)

      - run:
          name: Install System Dependencies
          command: |
            sudo apt-get update
            sudo apt-get install -y curl inotify-tools chromium-browser firefox
            # Install Node.js and Yarn
            curl -fsSL https://deb.nodesource.com/setup_16.x | sudo -E bash -
            sudo apt-get install -y nodejs
            curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -
            echo "deb https://dl.yarnpkg.com/debian/ stable main" | sudo tee /etc/apt/sources.list.d/yarn.list
            sudo apt-get update
            sudo apt-get install -y yarn
            # Install dockerize
            DOCKERIZE_VERSION="v0.6.1"
            sudo wget https://github.com/jwilder/dockerize/releases/download/$DOCKERIZE_VERSION/dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz
            sudo tar -C /usr/local/bin -xzvf dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz
            sudo rm dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz

      - restore_cache: # restores saved mix cache
          keys: # list of cache keys, in decreasing specificity
            - v5-mix-cache-{{ .Branch }}-{{ checksum "mix.lock" }}
            - v5-mix-cache-{{ .Branch }}
            - v5-mix-cache
      - restore_cache: # restores saved build cache
          keys:
            - v5-build-cache-{{ .Branch }}
            - v5-build-cache
      - run: mix do deps.get, compile # get updated dependencies & compile them
      - restore_cache:
          name: Restore Yarn Package Cache
          keys:
            - v1-yarn-packages-{{ .Branch }}-{{ checksum "yarn.lock" }}
            - v1-yarn-packages-{{ .Branch }}
            - v1-yarn-packages-master
            - v1-yarn-packages-
      - run:
          name: Install Node Dependencies
          command: yarn install
      - save_cache:
          name: Save Yarn Package Cache
          key: v1-yarn-packages-{{ .Branch }}-{{ checksum "yarn.lock" }}
          paths:
            - node_modules/
      - save_cache: # generate and store cache so `restore_cache` works
          key: v5-mix-cache-{{ .Branch }}-{{ checksum "mix.lock" }}
          paths: 
            - deps
      - save_cache: # make another less specific cache
          key: v5-mix-cache-{{ .Branch }}
          paths:
            - deps
      - save_cache: # you should really save one more cache just in case
          key: v5-mix-cache
          paths:
            - deps
      - save_cache: # don't forget to save a *build* cache, too
          key: v5-build-cache-{{ .Branch }}
          paths:
            - _build
      - save_cache: # and one more build cache for good measure
          key: v5-build-cache
          paths:
            - _build

      - run: # special utility that stalls main process until DB is ready
          name: Wait for DB
          command: dockerize -wait tcp://localhost:5432 -timeout 1m

      - run: yarn test # run all js tests in project
      - run: yarn run compile-test
      - run:
          command: |
            if [ "$COVERALLS_REPO_TOKEN" != "" ]; then
              mix coveralls.circle --include feature_test;
            else
              mix test --exclude feature_test;
              mix test --only feature_test;
            fi

      - store_test_results: # upload test results for display in Test Summary
          path: _build/test/junit
      - store_artifacts:
          path: screenshots

  deploy:
    machine: true
    working_directory: ~/app # directory where steps will run
    steps:
      - checkout
      - run:
          name: Deploy to Gigalixir
          command: |
            git remote add gigalixir https://$GIGALIXIR_EMAIL:$GIGALIXIR_API_KEY@git.gigalixir.com/$GIGALIXIR_APP_NAME.git
            commit_range_from_previous_build=$(echo $CIRCLE_COMPARE_URL | sed -n -e 's/^.*compare\///p')

            # trigger full rebuilds when elixir deps or prod environment configs have changed
            #   - also trigger full rebuilds when db migrations have been *added* since last push,
            #     as these wouldn't be run when doing a hot upgrade, but are run on fresh builds

            if git log $commit_range_from_previous_build --name-status --pretty="format:" | grep "phoenix_static_buildpack.config\config.exs\|prod.exs\|mix.exs\|mix.lock\|elixir_buildpack.config\|A[[:space:]]priv/repo/migrations"; then
              echo "Executing deploy cleaned of old dependencies"
              git -c http.extraheader="GIGALIXIR-CLEAN: true" push gigalixir HEAD:refs/heads/master --force;
            else
              echo "Executing deploy with hot code upgrade"
              git -c http.extraheader="GIGALIXIR-HOT: true" push gigalixir HEAD:refs/heads/master --force;
            fi

      - run:
          name: Notify HoneyBadger of Deploy
          command: |
            curl --data "deploy[environment]=production&deploy[revision]=$CIRCLE_SHA1&deploy[repository]=https://github.com/stride-nyc/remote_retro&api_key=$HONEYBADGER_API_KEY" "https://api.honeybadger.io/v1/deploys"

workflows:
  version: 2
  build-and-deploy:
    jobs:
      - build
      - deploy:
          requires:
            - build
          filters:
            branches:
              only: master
