version: 2.1

orbs:
  browser-tools: circleci/browser-tools@1.5.2

jobs:
  build:
    parallelism: 1
    docker:
      - image: cimg/elixir:1.16.0-erlang-26.2.1-browsers
        environment:
          MIX_ENV: test
          NODE_OPTIONS: --openssl-legacy-provider
          DISPLAY: :99
      - image: cimg/postgres:15.5-postgis

    working_directory: ~/app

    steps:
      - checkout

      # Install Elixir build tools
      - run: mix local.hex --force
      - run: mix local.rebar --force

      # Restore Mix dependency caches
      - restore_cache:
          keys:
            - v5-mix-cache-{{ .Branch }}-{{ checksum "mix.lock" }}
            - v5-mix-cache-{{ .Branch }}
            - v5-mix-cache

      - restore_cache:
          keys:
            - v5-build-cache-{{ .Branch }}
            - v5-build-cache

      # Get and compile Elixir dependencies
      - run: mix do deps.get, compile

      # Modern Yarn setup using Corepack
      - restore_cache:
          name: Restore Yarn Package Cache
          keys:
            - v3-yarn-{{ checksum "yarn.lock" }}
            - v3-yarn-

      - run:
          name: Install Node Dependencies
          command: |
            rm -rf node_modules
            
            # Enable and configure Corepack (built into Node.js)
            sudo corepack enable
            
            # Set up Yarn 4.6.0
            sudo corepack prepare yarn@4.6.0 --activate
            
            # Install dependencies with modern Yarn syntax
            yarn install --immutable
            
            # Verify installation
            yarn --version

      # Save Yarn cache with modern structure
      - save_cache:
          name: Save Yarn Package Cache
          key: v2-yarn-{{ checksum "yarn.lock" }}
          paths:
            - .yarn/cache
            - .yarn/install-state.gz

      # Save Mix caches
      - save_cache:
          key: v6-mix-cache-{{ .Branch }}-{{ checksum "mix.lock" }}
          paths: ["deps"]
      - save_cache:
          key: v6-mix-cache-{{ .Branch }}
          paths: ["deps"]
      - save_cache:
          key: v6-mix-cache
          paths: ["deps"]
      - save_cache:
          key: v6-build-cache-{{ .Branch }}
          paths: ["_build"]
      - save_cache:
          key: v6-build-cache
          paths: ["_build"]

      - run:
          name: Setup Database
          command: |
            # Wait for Postgres to be ready
            dockerize -wait tcp://localhost:5432 -timeout 1m

            # Create test database with manual commands first
            PGPASSWORD=postgres psql -h localhost -U postgres -c 'CREATE DATABASE remote_retro_test;'
            
            # Configure optimized database settings
            mix run -e '
              Application.put_env(:remote_retro, RemoteRetro.Repo,
                pool_size: 20,
                queue_target: 5000,
                queue_interval: 10000
              )
            '
            
            # Now run Ecto commands
            mix ecto.create --quiet || true  # The || true prevents failure if DB exists
            mix ecto.migrate --quiet

      - run:
          name: Verify Database Setup
          command: |
            # First, let's verify PostgreSQL is accepting connections
            echo "Verifying PostgreSQL connection..."
            max_attempts=5
            counter=1
            until PGPASSWORD=postgres psql -h localhost -U postgres -c '\l' > /dev/null 2>&1; do
              if [ $counter -eq $max_attempts ]; then
                echo "Failed to connect to PostgreSQL after $max_attempts attempts"
                exit 1
              fi
              echo "Attempt $counter of $max_attempts - Waiting for PostgreSQL..."
              sleep 3
              ((counter++))
            done
            echo "✓ PostgreSQL is accepting connections"

            # Now verify our specific database exists and is accessible
            echo "\nVerifying test database..."
            if PGPASSWORD=postgres psql -h localhost -U postgres -lqt | cut -d \| -f 1 | grep -qw remote_retro_test; then
              echo "✓ Database 'remote_retro_test' exists"
              
              # Verify we can connect to the specific database
              if PGPASSWORD=postgres psql -h localhost -U postgres -d remote_retro_test -c 'SELECT current_timestamp;' > /dev/null 2>&1; then
                echo "✓ Can connect to 'remote_retro_test' database"
                
                # Check if our migrations table exists
                if PGPASSWORD=postgres psql -h localhost -U postgres -d remote_retro_test -c '\dt schema_migrations' | grep -q schema_migrations; then
                  echo "✓ Migrations table exists"
                  
                  # Get the current migration version
                  current_version=$(PGPASSWORD=postgres psql -h localhost -U postgres -d remote_retro_test -t -c 'SELECT version FROM schema_migrations ORDER BY version DESC LIMIT 1;')
                  echo "✓ Current migration version: $current_version"
                else
                  echo "✗ Migrations table not found - running migrations..."
                  mix ecto.migrate
                fi
              else
                echo "✗ Cannot connect to 'remote_retro_test' database"
                exit 1
              fi
            else
              echo "✗ Database 'remote_retro_test' does not exist"
              exit 1
            fi

            # Verify database configuration matches our expectations
            mix run -e '
              db_config = Application.get_env(:remote_retro, RemoteRetro.Repo)
              expected_config = [
                hostname: "localhost",
                database: "remote_retro_test",
                username: "postgres",
                password: "postgres"
              ]
              
              Enum.each(expected_config, fn {key, expected_value} ->
                actual_value = db_config[key]
                if actual_value == expected_value do
                  IO.puts "✓ #{key}: #{actual_value}"
                else
                  IO.puts "✗ #{key} mismatch - expected: #{expected_value}, got: #{actual_value}"
                  System.halt(1)
                end
              end)
            '

      - run:
          name: Setup Test Environment
          command: |
            mix run -e '
              # First, let''s ensure our configuration is loaded properly
              IO.puts "Loading configuration..."
              Application.load(:remote_retro)
              
              # Let''s verify our database configuration
              db_config = Application.get_env(:remote_retro, RemoteRetro.Repo)
              IO.puts """
              Database configuration:
              - Hostname: #{db_config[:hostname]}
              - Database: #{db_config[:database]}
              - Username: #{db_config[:username]}
              - Pool Size: #{db_config[:pool_size]}
              """
              
              # Start our dependencies in the correct order
              IO.puts "\nStarting core dependencies..."
              {:ok, _} = Application.ensure_all_started(:logger)
              {:ok, _} = Application.ensure_all_started(:ssl)
              {:ok, _} = Application.ensure_all_started(:postgrex)
              
              # Start Ecto separately to better track any issues
              IO.puts "\nStarting Ecto..."
              {:ok, _} = Application.ensure_all_started(:ecto_sql)
              
              # Now start our application
              IO.puts "\nStarting RemoteRetro..."
              case Application.ensure_all_started(:remote_retro) do
                {:ok, started_apps} ->
                  IO.puts "Started applications: #{inspect(started_apps)}"
                {:error, {app, reason}} ->
                  IO.puts "Failed to start #{app}: #{inspect(reason)}"
                  System.halt(1)
              end
              
              # Important: Configure sandbox BEFORE trying to use the connection
              IO.puts "\nSetting up database sandbox..."
              :ok = Ecto.Adapters.SQL.Sandbox.mode(RemoteRetro.Repo, :manual)
              
              # Now check out a connection for this process
              :ok = Ecto.Adapters.SQL.Sandbox.checkout(RemoteRetro.Repo)
              
              # Make it shared so child processes can use it
              Ecto.Adapters.SQL.Sandbox.mode(RemoteRetro.Repo, {:shared, self()})
              
              # Add robust connection verification with detailed logging
              IO.puts "\nVerifying database connection..."
              max_attempts = 3
              
              result = Enum.reduce_while(1..max_attempts, {:error, nil}, fn attempt, _ ->
                IO.puts "\nAttempt #{attempt} of #{max_attempts}"
                :timer.sleep(2000)
                
                try do
                  case RemoteRetro.Repo.query("SELECT current_timestamp") do
                    {:ok, result} ->
                      timestamp = result.rows |> List.first() |> List.first()
                      IO.puts "✓ Database connection successful - Server time: #{timestamp}"
                      {:halt, {:ok, result}}
                    {:error, error} ->
                      IO.puts "✗ Query failed: #{inspect(error)}"
                      if attempt == max_attempts, do: {:halt, {:error, error}}, else: {:cont, {:error, error}}
                  end
                rescue
                  e in DBConnection.ConnectionError ->
                    IO.puts "✗ Connection error: #{Exception.message(e)}"
                    if attempt == max_attempts, do: {:halt, {:error, e}}, else: {:cont, {:error, e}}
                  e ->
                    IO.puts "✗ Unexpected error: #{inspect(e)}"
                    if attempt == max_attempts, do: {:halt, {:error, e}}, else: {:cont, {:error, e}}
                end
              end)

              case result do
                {:ok, _} -> 
                  IO.puts "\n✓ Database setup completed successfully"
                  # Proper cleanup
                  Ecto.Adapters.SQL.Sandbox.checkin(RemoteRetro.Repo)
                {:error, error} -> 
                  IO.puts "\n✗ Database setup failed: #{inspect(error)}"
                  # Ensure we clean up even on failure
                  Ecto.Adapters.SQL.Sandbox.checkin(RemoteRetro.Repo)
                  System.halt(1)
              end

              # Register cleanup on exit
              :ok = ExUnit.after_suite(fn ->
                IO.puts "\nCleaning up test environment..."
                :ok = Application.stop(:remote_retro)
                :ok = Application.stop(:wallaby)
                :ok = Application.stop(:phoenix)
              end)
            '

      - browser-tools/install-chrome
      - browser-tools/install-chromedriver

      - run:
          name: Check Chrome install
          command: |
            google-chrome --version
            chromedriver --version

      - run:
          name: Setup X server
          command: |
            # Clean up any stale X server processes and lock files
            sudo pkill Xvfb || true
            sudo rm -f /tmp/.X*-lock
            sudo rm -rf /tmp/.X11-unix
            
            # Start Xvfb
            Xvfb :99 -screen 0 1280x1024x24 &
            export DISPLAY=:99
            
            # Wait for Xvfb to be ready
            sleep 2

      - run: yarn test # run all js tests in project
      - run: yarn run compile-test
      - run:
          name: Run Tests
          command: |
            # Setup test environment with proper connection management
            mix run -e '
              # First load all necessary applications
              IO.puts "Loading applications..."
              Application.load(:remote_retro)
              {:ok, _} = Application.ensure_all_started(:remote_retro)
              
              # Configure sandbox mode for testing
              IO.puts "Configuring database sandbox..."
              :ok = Ecto.Adapters.SQL.Sandbox.mode(RemoteRetro.Repo, :manual)
              
              # Explicitly check out a connection for this process
              IO.puts "Checking out database connection..."
              :ok = Ecto.Adapters.SQL.Sandbox.checkout(RemoteRetro.Repo)
              
              # Allow other processes to share this connection
              Ecto.Adapters.SQL.Sandbox.mode(RemoteRetro.Repo, {:shared, self()})
              
              # Now verify database is ready
              IO.puts "Verifying database connection..."
              try do
                case RemoteRetro.Repo.query("SELECT 1") do
                  {:ok, _} -> 
                    IO.puts "✓ Database ready for testing"
                  {:error, error} -> 
                    IO.puts "✗ Database error: #{inspect(error)}"
                    System.halt(1)
                end
              after
                # Always check the connection back in
                Ecto.Adapters.SQL.Sandbox.checkin(RemoteRetro.Repo)
              end
            '
            
            echo "Running non-feature tests..."
            if ! mix test --exclude feature_test --trace; then
              echo "Non-feature tests failed"
              exit 1
            fi
            
            # echo "Running feature tests..."
            echo "feature tests are under construction"
            # if ! MIX_ENV=test TEST_DEBUG=1 mix test --only feature_test --trace; then
            #   echo "Feature tests failed"
            #   exit 1
            # fi
            
            # Run coverage if token is available
            # if [ "$COVERALLS_REPO_TOKEN" != "" ]; then
            #   echo "Running coverage report..."
            #   mix coveralls.circle --include feature_test
            # fi

      - store_test_results: # upload test results for display in Test Summary
          path: _build/test/junit
      - store_artifacts:
          path: screenshots
      - store_artifacts:
          path: browser_logs.log

  deploy:
    machine: true
    working_directory: ~/app # directory where steps will run
    steps:
      - checkout
      - run:
          name: Deploy to Gigalixir
          command: |
            git remote add gigalixir https://$GIGALIXIR_EMAIL:$GIGALIXIR_API_KEY@git.gigalixir.com/$GIGALIXIR_APP_NAME.git
            commit_range_from_previous_build=$(echo $CIRCLE_COMPARE_URL | sed -n -e 's/^.*compare\///p')

            if git log $commit_range_from_previous_build --name-status --pretty="format:" | grep "phoenix_static_buildpack.config\config.exs\|prod.exs\|mix.exs\|mix.lock\|elixir_buildpack.config\|A[[:space:]]priv/repo/migrations"; then
              echo "Executing deploy cleaned of old dependencies"
              git -c http.extraheader="GIGALIXIR-CLEAN: true" push gigalixir HEAD:refs/heads/master --force;
            else
              echo "Executing deploy with hot code upgrade"
              git -c http.extraheader="GIGALIXIR-HOT: true" push gigalixir HEAD:refs/heads/master --force;
            fi

      - run:
          name: Notify HoneyBadger of Deploy
          command: |
            curl --data "deploy[environment]=production&deploy[revision]=$CIRCLE_SHA1&deploy[repository]=https://github.com/stride-nyc/remote_retro&api_key=$HONEYBADGER_API_KEY" "https://api.honeybadger.io/v1/deploys"

workflows:
  version: 2
  build-and-deploy:
    jobs:
      - build
      - deploy:
          requires:
            - build
          filters:
            branches:
              only: master
